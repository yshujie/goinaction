package slice_test

import "fmt"

/**
✅ 题目：切片扩容陷阱题（共享 or 非共享）

a := []int{1, 2, 3}
b := a[:2]
c := append(b, 100)
d := append(b, 200, 201)

a[1] = 99

fmt.Println("a:", a)
fmt.Println("b:", b)
fmt.Println("c:", c)
fmt.Println("d:", d)

❓输出是什么？为什么？
请说明：
- a 的底层数组长度和容量
- c 是否与 a 共享底层数组
- d 是否与 a 共享底层数组
*/

func ExpandSlice() {
	// 声明并初始数切片 a，此时切片 a 的 len：3， cap： 3， array：[3]int{1, 2, 3}
	a := []int{1, 2, 3}

	// 通过截取切片 a 的方式声明切片 b
	// 因截取是[low, high, max]，则 a[:2] 的方式，是从下标为 0 的元素开始（包含），到下标为 2 的元素（不包含）
	// 对于切片 b： len = 2-0 = 2; cap = cap(a)-0 = 3; 底层数组 与 a 的底层数组是同一个
	// 固 b：[1, 2]
	// 注意：此时 a 和 b 两个切片的底层数组是同一个；切片 b 只是底层数组的一个数据窗口，长度为 2 ，上限为 3
	b := a[:2]

	// 通过向切片 b 追加元素的形式，创建了新的切片 c
	// 因切片 b 的 len=2，cap=3，说明向 b 中追加元素时，还有 1 个元素的空间可以使用
	// 因此切片 c 是在切片 b 的基础上，追加了一个元素 100，而此时并没有发生数组扩容
	// 对于切片 c：len = len(b)+1 = 3; cap = cap(b); 底层数组 与 a,b 的底层数组是同一个
	// 固 c：[1, 2, 100]
	// 注意：此时 a，b，c 三个切片的底层数组都是一个；此时虽然是 append() 函数，但底层数组都是同一个，而 append(b, 100) 更新了底层数组第三个元素的值
	c := append(b, 100)

	// 更新切片 a 索引为 1 的元素
	// 由于切片 a，b，c 的底层数组都是同一个，更新操作会影响至其他切片
	a[1] = 99

	// 通过向切片 b 中追加元素的形式，创建新的切片 d
	// 此次追加了 2 个元素，而切片 b 可扩充容量只有 1 （b.cap - v.len = 1），此时会创建一个新的底层数组，并赋值给切片 d
	// 对于切片 d：len = len(b) + 2 = 4; cap = cap(b) * 2 = 6; 底层数组则是新创建的数组
	// 固 d：[1, 99, 200, 201]
	d := append(b, 200, 201)

	fmt.Printf("a: %v \n", a) // 输出: a: 1, 99, 100
	fmt.Printf("b: %v \n", b) // 输出: b: 1, 99
	fmt.Printf("c: %v \n", c) // 输出: c: 1, 99, 100
	fmt.Printf("d: %v \n", d) // 输出: d: 1, 99, 200, 201
}
